import type { NextApiRequest, NextApiResponse } from 'next'
import { getSupabaseClient } from '@/lib/supabaseClient'
import { z } from 'zod'
import { videoSchema, Video } from '@/lib/types/videos' // Assuming Video type includes all necessary fields

// Define the expected request body schema
// Add all fields that are expected to be passed in the request body for creating a video.
// This should align with what you are inserting into the 'videos' table.
const createVideoRequestSchema = videoSchema.omit({ 
  id: true, // id is auto-generated
  created_at: true, // created_at is auto-generated
  updated_at: true, // updated_at is auto-generated by the DB
  // clips: true, // clips are handled separately or not part of initial video creation API
  // comments: true, // comments are handled separately
  // analysis_results: true, // analysis_results handled separately
  // user_id: true, // user_id might be inferred from session or explicitly passed if needed
}).extend({
  // If user_id is not part of videoSchema or needs to be explicitly passed and validated
  // user_id: z.string().uuid().optional(), // Example if you handle user_id here
});


// Define the expected response schema
const createVideoResponseSchema = z.object({
  video: videoSchema, // Return the full video object
})

type CreateVideoApiResponse = z.infer<typeof createVideoResponseSchema> | { error: string; issues?: z.ZodIssue[] }

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<CreateVideoApiResponse>
) {
  if (req.method !== 'POST') {
    res.setHeader('Allow', ['POST'])
    return res.status(405).json({ error: 'Method not allowed' })
  }

  const supabase = getSupabaseClient(req.headers.authorization)

  try {
    // Authenticate user
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return res.status(401).json({ error: 'Unauthorized' })
    }

    // Validate request body
    const parseResult = createVideoRequestSchema.safeParse(req.body)
    if (!parseResult.success) {
      return res.status(400).json({ error: 'Invalid request body', issues: parseResult.error.issues })
    }

    const videoDataToInsert = {
      ...parseResult.data,
      user_id: user.id, // Always associate the video with the authenticated user
      // Ensure all required fields by your 'videos' table are present
      // and default any optional ones if not provided and not defaulted by DB
    };

    // Insert video into Supabase
    const { data: newVideo, error: insertError } = await supabase
      .from('videos')
      .insert(videoDataToInsert)
      .select()
      .single() // Assuming you want to return the created video

    if (insertError) {
      console.error('Error inserting video:', insertError)
      // Check for specific Supabase errors if needed, e.g., unique constraint violation
      if (insertError.code === '23505') { // Unique violation
        return res.status(409).json({ error: 'A video with similar properties already exists.'});
      }
      throw new Error(insertError.message)
    }

    if (!newVideo) {
      console.error('Video data was not returned after insert.');
      throw new Error('Failed to create video, no data returned.');
    }
    
    // Validate the structure of the returned video (optional, but good practice)
    const validatedVideo = videoSchema.parse(newVideo);

    return res.status(201).json({ video: validatedVideo as Video })

  } catch (error: any) {
    console.error('Error in videos/create handler:', error)
    if (error instanceof z.ZodError) { // Handle Zod validation errors for the response itself
        return res.status(500).json({ error: 'Response data validation failed.', issues: error.issues });
    }
    const statusCode = error.message?.includes('Unauthorized') ? 401 : 500
    return res.status(statusCode).json({ error: error.message || 'An unknown internal server error occurred' })
  }
} 